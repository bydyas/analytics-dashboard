[![Analytics Dashboard CI](https://github.com/bydyas/analytics-dashboard/actions/workflows/analytics-dashboard.yml/badge.svg)](https://github.com/bydyas/analytics-dashboard/actions/workflows/analytics-dashboard.yml)

# The Analytics Dashboard

- [Structure](#structure)
- [Set up](#set-up)
- [Cache](#cache)
- [Dataset Mock](#dataset-mock)
- [Debounce](#debounce)

### Structure

```shell
.
├── apps
│   ├── dashboard-bff-service       # Backend-for-Frontend service                
│   └── dashboard-frontend-service  # Frontend UI service                      
└── packages
    |── @common/health              # Health check
    |── @common/logger              # Logs to save into file.txt
    |── @common/cache               # Cache
    |── @common/contracts           # Types
    ├── @common/eslint-config       # `eslint` configurations (includes `prettier`)
    ├── @common/jest-config         # `jest` configurations
    ├── @common/typescript-config   # `tsconfig.json`s used throughout the monorepo
```

### Set up

via __Docker__:
```shell
docker-compose up
```

via __package manager__:
```shell
yarn install & yarn dev
```

If you want to run the particular app:
```shell
yarn workspace [app-name] dev
```

=> [Backend Swagger Api](http://localhost:3001/api)

=> [Dashboard Web](http://localhost:3000)

### Cache

I made reusable caching module ```@common/cache``` based on **node-cache**. It provides a method to generate keys by serializing all relevant input parameters, converting Dates to timestamps, and hashing the result to ensure uniqueness. This guarantees that identical requests reuse cached data, preventing redundant backend calculations.

### Dataset Mock

The mock dataset is an array of sales objects, each containing a timestamp randomly generated by ```faker.js``` within a given date range and a value representing the sale amount. Data aggregation is implemented by filtering sales within the requested interval, grouping them by formatted dates according to the aggregationLevel (daily, weekly, monthly), summing their values, and returning a sorted array of aggregated totals. **The aggregation may suffer O(n)**.

### Debounce

The debouncing logic is implemented using a custom ```useDebouncedCallback``` hook, which wraps any setter function (like ```setStartDate```) and delays its execution by a specified interval. This ensures that rapid changes to filters only update state after the user stops interacting, preventing multiple unnecessary API calls and reducing backend load.